<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1 style="color:red">JavaScript</h1>
    <h2>concat</h2>
    <p>One characteristic of the functional programming paradigm is the use of immutable data structures.</p>
    <p>In React code, it is preferable to use the method concat, which creates a new array with the added item. This ensures the original array remains unchanged.</p>
    <script>
        const t = [1, -1, 3]

        const t2 = t.concat(5)  // creates new array

        console.log(t)  // [1, -1, 3] is printed
        console.log(t2) // [1, -1, 3, 5] is printed
    </script>
    <p>The method call t.concat(5) does not add a new item to the old array but returns a new array which, besides containing the items of the old array, also contains the new item.</p>


    <h2>map</h2>
    <p>map creates a new array, for which the function given as a parameter is used to create the items</p>
    <script>
        const t1 = [1, 2, 3]

        const m1 = t1.map(value => value * 2)
        console.log(m1)   // [2, 4, 6] is printed
    </script>

    <h2>this</h2>
    <p>the value of <i>this</i> in JavaScript is defined based on how the method is being called. When setTimeout is calling the method, it is the JavaScript engine that actually calls the method and, at that point, <i>this</i> refers to the <b>global object</b>.</p>
    <script>
    const arto = {
        name: 'Arto Hellas',
        greet: function() {
            console.log('hello, my name is ' + this.name)
        },
    }

    setTimeout(arto.greet, 1000)</script>

    <p>There are several mechanisms by which the original this can be preserved. One of these is using a method called <b>bind:</b></p>
    <script>
        setTimeout(arto.greet.bind(arto), 1000)
    </script>
    <p>Calling <b>arto.greet.bind(arto)</b> creates a new function where this is bound to point to Arto, independent of where and how the method is being called.</p>

    <h1 style="color: blue">Component state, Event handlers</h1>

    <a href="https://react.dev/learn/state-a-components-memory"><h2>State?</h2></a>
    <p>Components often need to change what is on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of <b>component-specific memory</b> is called <i>state</i>.</p>

    <h2>State Hook</h2>
    <p>The function call adds state to the component and renders it initialized with the value zero. The function returns an array that contains two items. We assign the items to the variables counter and setCounter by using the destructuring assignment syntax shown earlier.
    </p>
    <script>
        const [ counter, setCounter ] = useState(0)
    </script>
    <p>The counter variable is assigned the initial value of state, which is zero. The variable setCounter is assigned a function that will be used to modify the state.</p>

    <p>When the state modifying function <i>setCounter</i> is called, React re-renders the component which means that the function body of the component function gets re-executed</p>

    <h2>Event handling</h2>

    <p>We define the event handlers for our buttons where we declare their onClick attributes: <span style="color: red">The setCounter function is called <b>only when a user clicks the button</b>.</span>
    </p>
    <pre>
        <code>
            &lt;button onClick={<span style="color: red">() =&gt;setCounter(counter + 1)</span>}&gt; plus&lt;/button&gt;
        </code>
    </pre>

    <p>Not ussing this way! it will make  infinite loop </p>
    <pre>
        <code>
            &lt;button onClick={<span style="color: red">setCounter(counter + 1)</span>}&gt;plus&lt;/button&gt;
        </code>
    </pre>

    <p>But usually defining event handlers within JSX-templates is not a good idea</p>
</body>
</html>
